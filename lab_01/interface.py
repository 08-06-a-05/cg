# Form implementation generated from reading ui file '.\kg1.ui'
#
# Created by: PyQt6 UI code generator 6.6.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.
from typing import TypeVar, Type, Optional

from PyQt6 import QtCore, QtWidgets
from PyQt6.QtCore import Qt, QLineF, QRectF
from PyQt6.QtGui import QColor, QFont
from PyQt6.QtWidgets import QMessageBox, QTableWidgetItem

from mediator import SceneObjects


# TODO: Заменить в надписи о вершинах треугольника ограничение 3-мя знаками после запятой

class Ui_MainWindow:

    def __init__(self, main_window, scene_objects: SceneObjects):
        self.objects_id: list[int] = []
        self.temporary_objects_id: list[int] = []
        self.cell_just_changed = False
        self.main_window = main_window
        self.scene_objects = scene_objects
        main_window.setObjectName("MainWindow")
        main_window.resize(1200, 800)
        self.central_widget = QtWidgets.QWidget(parent=main_window)
        self.central_widget.setObjectName("central_widget")
        self.resultView = QtWidgets.QGraphicsView(parent=self.central_widget)
        self.resultView.setGeometry(QtCore.QRect(10, 10, 610, 610))
        self.scene = QtWidgets.QGraphicsScene(parent=self.resultView)
        self.scene.setSceneRect(5, 5, 600, 600)
        self.resultView.setScene(self.scene)
        self.resultView.setObjectName("resultView")
        self.text_result_viewer = QtWidgets.QTextBrowser(parent=self.central_widget)
        self.text_result_viewer.setGeometry(QtCore.QRect(650, 480, 350, 250))
        self.pointsDataView = QtWidgets.QTableWidget(0, 3, parent=self.central_widget)
        self.pointsDataView.hideColumn(0)
        self.pointsDataView.setGeometry(QtCore.QRect(650, 10, 350, 440))
        self.pointsDataView.setHorizontalHeaderLabels(("Id", "x", "y"))
        self.pointsDataView.setObjectName("pointsData")
        self.pointsDataView.cellChanged.connect(self.change_point)
        self.add_button = QtWidgets.QPushButton(parent=self.central_widget)
        self.add_button.setGeometry(QtCore.QRect(460, 670, 120, 31))
        self.add_button.setObjectName("add_button")
        self.add_x_value = QtWidgets.QLineEdit(parent=self.central_widget)
        self.add_x_value.setGeometry(QtCore.QRect(230, 670, 100, 31))
        self.add_x_value.setText("")
        self.add_x_value.setObjectName("add_x_value")
        self.add_y_value = QtWidgets.QLineEdit(parent=self.central_widget)
        self.add_y_value.setGeometry(QtCore.QRect(350, 670, 100, 31))
        self.add_y_value.setText("")
        self.add_y_value.setObjectName("add_y_value")
        self.xValueLabel = QtWidgets.QLabel(parent=self.central_widget)
        self.xValueLabel.setGeometry(QtCore.QRect(250, 645, 60, 20))
        self.xValueLabel.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.xValueLabel.setObjectName("xValueLabel")
        self.xValueLabel_2 = QtWidgets.QLabel(parent=self.central_widget)
        self.xValueLabel_2.setGeometry(QtCore.QRect(380, 645, 30, 22))
        self.xValueLabel_2.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.xValueLabel_2.setObjectName("xValueLabel_2")
        self.remove_button = QtWidgets.QPushButton(parent=self.central_widget)
        self.remove_button.setGeometry(QtCore.QRect(400, 730, 90, 31))
        self.remove_button.setObjectName("remove_button")
        self.xValueLabel_8 = QtWidgets.QLabel(parent=self.central_widget)
        self.xValueLabel_8.setGeometry(QtCore.QRect(340, 710, 30, 22))
        self.xValueLabel_8.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.xValueLabel_8.setObjectName("xValueLabel_8")
        self.remove_id_value = QtWidgets.QLineEdit(parent=self.central_widget)
        self.remove_id_value.setGeometry(QtCore.QRect(330, 730, 50, 31))
        self.remove_id_value.setText("")
        self.remove_id_value.setObjectName("remove_id_value")
        self.xValueLabel_5 = QtWidgets.QLabel(parent=self.central_widget)
        self.xValueLabel_5.setGeometry(QtCore.QRect(230, 620, 300, 22))
        self.xValueLabel_5.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.xValueLabel_5.setObjectName("xValueLabel_5")
        main_window.setCentralWidget(self.central_widget)
        self.menubar = QtWidgets.QMenuBar(parent=main_window)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 647, 22))
        self.menubar.setObjectName("menubar")
        main_window.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=main_window)
        self.statusbar.setObjectName("statusbar")
        main_window.setStatusBar(self.statusbar)

        self.calc_button = QtWidgets.QPushButton(parent=self.central_widget)
        self.calc_button.setGeometry(QtCore.QRect(520, 730, 150, 31))
        self.calc_button.setObjectName("calc_button")
        self.clear_points_button = QtWidgets.QPushButton(parent=self.central_widget)
        self.clear_points_button.setGeometry(QtCore.QRect(120, 730, 140, 31))
        self.clear_points_button.setObjectName("clear_points_button")

        self.translate_ui()
        QtCore.QMetaObject.connectSlotsByName(main_window)
        self.add_button.clicked.connect(self.clicked_add_button)
        self.remove_button.clicked.connect(self.clicked_remove_button)
        self.calc_button.clicked.connect(self.calc_res)
        self.clear_points_button.clicked.connect(self.clear_points)

    def translate_ui(self):
        _translate = QtCore.QCoreApplication.translate
        self.main_window.setWindowTitle(_translate("MainWindow", "Лабораторная работа №1"))
        self.add_button.setText(_translate("MainWindow", "Добавить"))
        self.xValueLabel.setText(_translate("MainWindow", "x"))
        self.xValueLabel_2.setText(_translate("MainWindow", "y"))
        self.remove_button.setText(_translate("MainWindow", "Удалить"))
        self.clear_points_button.setText(_translate("MainWindow", "Очистить все"))
        self.calc_button.setText(_translate("MainWindow", "Рассчитать"))
        self.xValueLabel_8.setText(_translate("MainWindow", "id"))
        self.xValueLabel_5.setText(_translate("MainWindow", "Операции над точками"))

    T = TypeVar("T")

    @staticmethod
    def validate(req_type: Type[float], s: str) -> bool:
        """
        Проверяет, что функция соответствует переданному типу.

        :param req_type: Ожидаемый тип, к которому должна быть приводима строка.
        :param s: Строка.
        :return: Является ли строка корректным значением.
        """
        try:
            req_type(s)
        except ValueError:
            return False
        else:
            return True

    def change_point(self, row: int, column: int) -> None:
        """
        Обработчик события изменения точки.

        :param row: Строка, в которой произошло изменение.
        :param column: Столбец, в котором произошло изменение.
        :return: None
        """
        if self.cell_just_changed:
            self.cell_just_changed = False
            return
        self.clear_res()
        if column == 0:
            raise ValueError
        item: QTableWidgetItem = self.pointsDataView.item(row, column)
        point_id: int = int(self.pointsDataView.item(row, 0).text())
        if not self.validate(float, item.text()):
            self.show_error("Ошибка при изменении точки", "Некорректное значение поля")
            old_point_coordinates: tuple[float, float] = self.scene_objects.get_point_pos(point_id)
            self.pointsDataView.setItem(row, column, QTableWidgetItem(str(old_point_coordinates[column - 1])))
            return
        new_value: float = float(item.text())
        if column == 1:
            self.scene_objects.set_point_pos(point_id, x=new_value)
        elif column == 2:
            self.scene_objects.set_point_pos(point_id, y=new_value)

    def draw_polygon(self, edges: tuple[tuple[tuple[float, float], tuple[float, float]], ...], color: QColor) -> None:
        """
        Отрисовка полигона, представленного в виде кортежа своих ребер. Каждое ребро представляет собой кортеж точек.
        Каждая точка - кортеж из двух чисел: координат.

        :param edges: Кортеж ребер.
        :param color: Цвет
        :return: None
        """
        for edge in edges:
            p1 = edge[0]
            p2 = edge[1]
            self.scene.addLine(QLineF(*p1, *p2), color)

    def draw_circle(self, render_circle: tuple[float, float, float, float], color: QColor) -> None:
        """
        Отрисовка круга. Круг представлен кортежем, описывающим квадрат, в который он вписан. Стороны квадрата
        параллельны осям координат. Первые две координаты задают левый верхний угол квадрата, третья - ширину, а
        четвертая - высоту.

        :param render_circle: Кортеж, задающий круг
        :param color: Цвет
        :return: None
        """
        self.scene.addEllipse(QRectF(*render_circle), color)

    def clear_points(self):
        self.scene_objects.remove_all()
        self.pointsDataView.setRowCount(0)
        self.clear_res()
        self.objects_id.clear()

    def show_point_coordinates(self, point_coordinates: tuple[float, float], position: tuple[float, float]) -> None:
        text = self.scene.addText(f"({point_coordinates[0]:.3f}, {point_coordinates[1]:.3f})")
        if position[0] + text.boundingRect().width() > 560:
            text.setPos(position[0] - text.boundingRect().width(), position[1])
        else:
            text.setPos(*position)

    def draw_axes(self) -> None:
        """
        Отрисовка осей координат.

        :return: None
        """
        # TODO: Переписать с использованием размеров сцены
        scene_rect: QRectF = self.scene.sceneRect()
        self.scene.addLine(5, 585, 595, 585)
        self.scene.addLine(20, 5, 20, 600)
        self.scene.addLine(20, 5, 15, 8)
        self.scene.addLine(20, 5, 25, 8)
        self.scene.addLine(595, 585, 592, 580)
        self.scene.addLine(595, 585, 592, 590)
        x_label = self.scene.addText("x", QFont("Times", 9))
        y_label = self.scene.addText("y", QFont("Times", 9))
        x_label.setPos(590, 585)
        y_label.setPos(2, 1)

    def gen_text(self, triangle_id: int, circle_id: int) -> str:
        """
        Генерация текста ответа. Текст содержит информацию о положении треугольника, его площади, аналогичные данные
        о его описанной окружности, а также разницу их площадей.

        :param triangle_id: Id треугольника
        :param circle_id: Id окружности
        :return: Текст
        """
        triangle_points = self.scene_objects.polygon_points(triangle_id)
        triangle_square = self.scene_objects.polygon_square(triangle_id)
        circumcircle_center = self.scene_objects.circle_center(circle_id)
        triangle_circumcircle_radius = self.scene_objects.circle_radius(circle_id)
        triangle_circumcircle_square = self.scene_objects.circle_square(circle_id)
        return (f"Максимальная разность между площадью треугольника и описанной окружностью = "
                f"{triangle_circumcircle_square - triangle_square:.3f}. Данный треугольник образован точками с "
                f"координатами {triangle_points}. Его площадь = "
                f"{triangle_square:.3f}. Центр описанной"
                f" окружности находится в точке: ({circumcircle_center[0]:.3f}, {circumcircle_center[0]:.3f}), "
                f"ее радиус = {triangle_circumcircle_radius:.3f}, а площадь = {triangle_circumcircle_square:.3f}.")

    def calc_res(self):
        """
        Функция поиска нужного треугольника.

        :return:
        """
        # TODO: Модифицировать эту функцию
        req_triangle_id: Optional[int] = self.scene_objects.find_selected_triangle()
        if req_triangle_id is None:
            self.show_error("Ошибка при обработке", "Заданный треугольник не найден")
            return
        req_circle_id: int = self.scene_objects.add_circumcircle(req_triangle_id)
        self.temporary_objects_id.append(req_triangle_id)
        self.temporary_objects_id.append(req_circle_id)
        real_coordinates: tuple[tuple[float, float], ...] = self.scene_objects.polygon_points(req_triangle_id)
        real_point_center: tuple[float, float] = self.scene_objects.circle_center(req_circle_id)
        self.text_result_viewer.setText(self.gen_text(req_triangle_id, req_circle_id))
        border: tuple[float, float, float, float] = self.scene_objects.render_circle(req_circle_id)
        x_offset = -border[2] / 2 - border[0]
        y_offset = -border[3] / 2 - border[1]
        scale = (self.scene.sceneRect().width() - 2 * 50) / border[2]
        self.scene_objects.move_polygon(req_triangle_id, x_offset, y_offset)
        self.scene_objects.move_circle(req_circle_id, x_offset, y_offset)
        self.scene_objects.scale_polygon(req_triangle_id, scale, -scale)
        self.scene_objects.scale_circle(req_circle_id, scale)
        screen_center: tuple[float, float] = self.scene.sceneRect().width() / 2, self.scene.sceneRect().height() / 2
        self.scene_objects.move_polygon(req_triangle_id, *screen_center)
        self.scene_objects.move_circle(req_circle_id, *screen_center)
        self.draw_polygon(self.scene_objects.render_polygon(req_triangle_id), QColor("red"))
        self.draw_circle(self.scene_objects.render_circle(req_circle_id), QColor("black"))
        self.draw_axes()
        for i, p in enumerate(self.scene_objects.polygon_points(req_triangle_id)):
            self.show_point_coordinates(real_coordinates[i], p)
        self.show_point_coordinates(real_point_center, self.scene_objects.circle_center(req_circle_id))
        rendered_triangle = self.scene_objects.render_polygon(req_triangle_id)
        e1_center: tuple[float, float] = (rendered_triangle[0][0][0] + rendered_triangle[0][1][0]) / 2, \
                                         (rendered_triangle[0][0][1] + rendered_triangle[0][1][1]) / 2
        e2_center: tuple[float, float] = (rendered_triangle[1][0][0] + rendered_triangle[1][1][0]) / 2, \
                                         (rendered_triangle[1][0][1] + rendered_triangle[1][1][1]) / 2
        e3_center: tuple[float, float] = (rendered_triangle[2][0][0] + rendered_triangle[2][1][0]) / 2, \
                                         (rendered_triangle[2][0][1] + rendered_triangle[2][1][1]) / 2
        circle_center: tuple[float, float] = self.scene_objects.circle_center(req_circle_id)
        if abs(e1_center[0] - circle_center[0]) < 1e-6 and abs(e1_center[1] - circle_center[1]) < 1e-6:
            self.scene.addLine(*e2_center, *circle_center)
            self.scene.addLine(*e3_center, *circle_center)
        elif abs(e2_center[0] - circle_center[0]) < 1e-6 and abs(e2_center[1] - circle_center[1]) < 1e-6:
            self.scene.addLine(*e1_center, *circle_center)
            self.scene.addLine(*e3_center, *circle_center)
        else:
            self.scene.addLine(*e1_center, *circle_center)
            self.scene.addLine(*e2_center, *circle_center)

    def clear_res(self) -> None:
        """
        Очистка сцены

        :return: None
        """
        self.scene.clear()
        self.text_result_viewer.clear()
        for cur_id in self.temporary_objects_id:
            self.scene_objects.remove_object(cur_id)
        self.temporary_objects_id.clear()

    def add_point(self, x: float, y: float) -> None:
        """
        Добавление точки.

        :param x: Координата точки
        :param y: Координата точки
        :return: None
        """
        # print(self.scene_objects.points_num())
        new_point_id: int = self.scene_objects.add_point(x, y)
        self.objects_id.append(new_point_id)
        new_point_index: int = self.scene_objects.points_num() - 1
        self.pointsDataView.setRowCount(new_point_index + 1)
        self.cell_just_changed = True
        self.pointsDataView.setItem(new_point_index, 0, QTableWidgetItem(str(new_point_id)))
        self.cell_just_changed = True
        self.pointsDataView.item(new_point_index, 0).setFlags(Qt.ItemFlag.ItemIsEditable)
        self.cell_just_changed = True
        self.pointsDataView.setItem(new_point_index, 1, QTableWidgetItem(str(x)))
        self.cell_just_changed = True
        self.pointsDataView.setItem(new_point_index, 2, QTableWidgetItem(str(y)))

    def clicked_add_button(self) -> None:
        """
        Обработчик нажатия кнопки добавления точки.

        :return: None
        """
        if not self.validate(float, self.add_x_value.text()):
            self.show_error("Ошибка при добавлении точки", "Некорректное значение поля x")
            return
        if not self.validate(float, self.add_y_value.text()):
            self.show_error("Ошибка при добавлении точки", "Некорректное значение поля y")
            return
        x: float = float(self.add_x_value.text())
        y: float = float(self.add_y_value.text())
        self.add_point(x, y)
        self.clear_res()

    def show_error(self, title: str, message: str) -> None:
        """
        Отображение сообщения об ошибке.

        :param title: Заголовок сообщения
        :param message: Текст сообщения
        :return: None
        """
        QMessageBox.critical(self.main_window, title, message)

    def remove_point(self, point_id: int) -> None:
        """
        Удаление точки.

        :param point_id: Id удаляемой точки
        :return: None
        """
        if not self.scene_objects.remove_point(point_id):
            self.show_error("Ошибка при удалении точки", "Внутренняя ошибка")

    def clicked_remove_button(self) -> None:
        """
        Обработчик нажатия кнопки удаления.

        :return: None
        """
        if not self.validate(int, self.remove_id_value.text()):
            self.show_error("Ошибка при удалении точки", "Некорректное значение поля Id")
            return
        point_index: int = int(self.remove_id_value.text())
        if point_index <= 0 or point_index > self.scene_objects.points_num():
            self.show_error("Ошибка при удалении точки", "Некорректное значение поля Id")
            return
        self.clear_res()
        point_id: int = int(self.pointsDataView.item(point_index - 1, 0).text())
        self.remove_point(point_id)
        self.pointsDataView.removeRow(point_index - 1)

    def show(self) -> None:
        """
        Отображение приложения.

        :return: None
        """
        self.main_window.show()

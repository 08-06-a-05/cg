# Form implementation generated from reading ui file '.\kg3.ui'
#
# Created by: PyQt6 UI code generator 6.6.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.
import math
import time
from typing import Type, Callable

import matplotlib.pyplot as plt
from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtGui import QPainter, QColor
from PyQt6.QtWidgets import QMessageBox, QWidget

ladders = 0

class Example(QWidget):

    def __init__(self, parent=None):
        super().__init__(parent)
        self.lines_list: list[tuple[int, int, int, int, QColor, Callable]] = []
        self.draw_method: Callable[[int, int, int, int, QPainter], None] = None
        self.initUI()

    def set_draw_method(self, draw_method: Callable[[int, int, int, int, QPainter], None]):
        self.draw_method = draw_method

    def clear_lines_list(self):
        self.lines_list.clear()

    def add_line(self, line: tuple[int, int, int, int, QColor, Callable]):
        self.lines_list.append(line)

    def initUI(self):
        self.setMinimumSize(50, 50)
        self.setGeometry(490, 20, 570, 650)
        # self.setAttribute(QtCore.WA_StyledBackground, True)
        # self.setStyleSheet('background-color: red;')
        p = self.palette()
        p.setColor(self.backgroundRole(), QColor("white"))
        self.setPalette(p)
        self.setAutoFillBackground(True)
        # self.f
        self.setWindowTitle('Points')
        # self.show()

    def paintEvent(self, e):
        qp = QPainter()
        qp.setRenderHint(QPainter.RenderHint.Antialiasing, False)
        qp.begin(self)
        for line in self.lines_list:
            qp.setPen(line[4])
            self.draw_method = line[5]
            if self.draw_method is None:
                qp.drawLine(line[0], line[1], line[2], line[3])
            else:
                self.draw_method(line[0], line[1], line[2], line[3], qp)
        qp.end()

def sign(x: float) -> int:
    if x > 0:
        return 1
    elif x == 0:
        return 0
    else:
        return -1


def show_bar(x, y):
    # plot:
    fig2, ax = plt.subplots()
    fig2.set_figwidth(100)
    translate = {"bres_float": "Вещественный\nалг. Брезенхема", "bres_int": "Целочисленный\nалг. Брезенхема",
                 "light_brem": "Алг. Брезенхема\nсо сглаживанием", "alg_vu": "Алг. ВУ", "digital": "Алг. ЦДА"}
    ax.bar(tuple(translate[i] for i in x), y, width=1, edgecolor="white", linewidth=0.7)

    # ax.set(xlim=(0, 8), xticks=np.arange(1, 8),
    #        ylim=(0, 8), yticks=np.arange(1, 8))

    fig2.show()


counter = 0
fig: plt.Figure = plt.figure(figsize=(100, 100))


def show_graph(x, y, name):
    global counter
    global fig
    if name == "bres_float":
        counter = 1
        fig.text(0.3, 0.95, "Количество ступенек в зависимости от угла наклона отрезка", fontsize=14)
        fig.text(0.7, 0.4, "Длина линии: 200", fontsize=14)

    ax = fig.add_subplot(2, 3, counter)
    ax.plot(x, y)
    ax.set_title(name)
    # plt.title(name)
    # ax.set(xlim=(0, 8), xticks=np.arange(1, 8),
    #        ylim=(0, 8), yticks=np.arange(1, 8))
    counter += 1
    if counter == 6:
        fig.show()


def digital_differential_analyzer(start_x: int, start_y: int, end_x: int, end_y: int, qp: QPainter, calc_ladders=False):
    global ladders
    if calc_ladders:
        ladders = 0
    if start_x == end_x and start_y == end_y:
        qp.drawPoint(start_x, start_y)
        return
    l: int = max(abs(start_x - end_x), abs(start_y - end_y))
    dx: float = (end_x - start_x) / l
    dy: float = (end_y - start_y) / l
    cur_x: float = start_x  # + 0.5 * sign(dx)
    cur_y: float = start_y  # + 0.5 * sign(dy)
    last_p_x = -1
    last_p_y = -1
    for i in range(l + 1):
        qp.drawPoint(round(cur_x), round(cur_y))
        if calc_ladders:
            if round(cur_x) != last_p_x and round(cur_y) != last_p_y:
                ladders += 1
                last_p_x = round(cur_x)
                last_p_y = round(cur_y)
        cur_x += dx
        cur_y += dy


def bresenham_algorithm_float(start_x: int, start_y: int, end_x: int, end_y: int, qp: QPainter, calc_ladders=False):
    global ladders
    if calc_ladders:
        ladders = 0
    if start_x == end_x and start_y == end_y:
        qp.drawPoint(start_x, start_y)
        return
    cur_x = start_x
    cur_y = start_y
    dx: int = end_x - start_x
    dy: int = end_y - start_y
    sx = sign(dx)
    sy = sign(dy)
    dx = abs(dx)
    dy = abs(dy)
    trade = False
    if dy >= dx:
        dx, dy = dy, dx
        trade = True
    m: float = dy / dx
    e: float = m - 0.5
    last_p_x = -1
    last_p_y = -1
    for i in range(dx + 1):
        qp.drawPoint(cur_x, cur_y)
        if calc_ladders:
            if cur_x != last_p_x and cur_y != last_p_y:
                ladders += 1
                last_p_x = cur_x
                last_p_y = cur_y
        if e >= 0:
            if trade:
                cur_x += sx
            else:
                cur_y += sy
            e -= 1
        e += m
        if trade:
            cur_y += sy
        else:
            cur_x += sx


def bresenham_algorithm_int(start_x: int, start_y: int, end_x: int, end_y: int, qp: QPainter, calc_ladders=False):
    global ladders
    if calc_ladders:
        ladders = 0
    if start_x == end_x and start_y == end_y:
        qp.drawPoint(start_x, start_y)
        return
    cur_x: int = start_x
    cur_y: int = start_y
    dx: int = end_x - start_x
    dy: int = end_y - start_y
    sx: int = sign(dx)
    sy: int = sign(dy)
    dx = abs(dx)
    dy = abs(dy)
    trade: bool = False
    if dy >= dx:
        dx, dy = dy, dx
        trade = True
    c_dx: int = dx << 1
    c_dy: int = dy << 1
    e: int = 2 * dy - dx
    last_p_x = -1
    last_p_y = -1
    for i in range(dx + 1):
        qp.drawPoint(cur_x, cur_y)
        if calc_ladders:
            if last_p_x != cur_x and last_p_y != cur_y:
                ladders += 1
                last_p_x = cur_x
                last_p_y = cur_y
        if e >= 0:
            if trade:
                cur_x += sx
            else:
                cur_y += sy
            e -= c_dx
        if trade:
            cur_y += sy
        else:
            cur_x += sx
        e += c_dy


def alg_vu(start_x: int, start_y: int, end_x: int, end_y: int, qp: QPainter, calc_ladders=False):
    global ladders
    if calc_ladders:
        ladders = 0
    if start_x == end_x and start_y == end_y:
        qp.drawPoint(start_x, start_y)
        return
    if start_x == end_x:
        if calc_ladders:
            ladders = 0
        ds = sign(end_y - start_y)
        dy = abs(end_y - start_y)
        for i in range(dy + 1):
            qp.drawPoint(start_x, start_y)
            start_y += ds
        return
    if start_y == end_y:
        if calc_ladders:
            ladders = 0
        ds = sign(end_x - start_x)
        dx = abs(end_x - start_x)
        for i in range(dx + 1):
            qp.drawPoint(start_x, start_y)
            start_x += ds
        return

    cur_color = qp.pen().color().rgba()
    save_color = cur_color
    colors = [0] * 3
    colors[2] = cur_color % 256
    cur_color //= 256
    colors[1] = cur_color % 256
    cur_color //= 256
    colors[0] = cur_color % 256

    dx = end_x - start_x
    dy = end_y - start_y
    trade = False
    if abs(dy) > abs(dx):
        trade = True
        dy, dx = dx, dy
        if end_y < start_y:
            start_x, end_x = end_x, start_x
            start_y, end_y = end_y, start_y
    else:
        if end_x < start_x:
            start_x, end_x = end_x, start_x
            start_y, end_y = end_y, start_y
    grad = dy / dx
    qp.setPen(QtGui.QColor(colors[0], colors[1], colors[2], 255))
    qp.drawPoint(start_x, start_y)
    if trade:
        interx = start_x + grad
    else:
        intery = start_y + grad
    if calc_ladders:
        if abs(dx) > abs(dy):
            ladders = abs(dy)
        else:
            ladders = abs(dx)
    last_p_x = -1
    last_p_y = -1
    if not trade:
        for cur_x in range(start_x + 1, end_x):
            qp.setPen(QtGui.QColor(colors[0], colors[1], colors[2], round(255 * (1 - intery + int(intery)))))
            qp.drawPoint(cur_x, int(intery))
            qp.setPen(QtGui.QColor(colors[0], colors[1], colors[2], round(255 * (intery - int(intery)))))
            qp.drawPoint(cur_x, int(intery) + 1)
            intery += grad
    else:
        for cur_y in range(start_y + 1, end_y):
            qp.setPen(QtGui.QColor(colors[0], colors[1], colors[2], round(255 * (1 - interx + int(interx)))))
            qp.drawPoint(int(interx), cur_y)
            qp.setPen(QtGui.QColor(colors[0], colors[1], colors[2], round(255 * (interx - int(interx)))))
            qp.drawPoint(int(interx) + 1, cur_y)
            interx += grad

    qp.setPen(QtGui.QColor(colors[0], colors[1], colors[2], 255))
    qp.drawPoint(end_x, end_y)

    qp.setPen(QtGui.QColor(save_color))


def light_brem(start_x: int, start_y: int, end_x: int, end_y: int, qp: QPainter, calc_ladders=False):
    global ladders
    if calc_ladders:
        ladders = 0
    I = 7
    if start_x == end_x and start_y == end_y:
        qp.drawPoint(start_x, start_y)
        return
    cur_x = start_x
    cur_y = start_y
    dx: int = end_x - start_x
    dy: int = end_y - start_y
    sx = sign(dx)
    sy = sign(dy)
    dx = abs(dx)
    dy = abs(dy)
    trade = False
    if dy >= dx:
        dx, dy = dy, dx
        trade = True
    m: float = dy / dx
    w: float = 1 - m
    e: float = 0.5

    cur_color = qp.pen().color().rgba()
    save_color = cur_color
    colors = [0] * 3
    colors[2] = cur_color % 256
    cur_color //= 256
    colors[1] = cur_color % 256
    cur_color //= 256
    colors[0] = cur_color % 256
    qp.setPen(QtGui.QColor(colors[0], colors[1], colors[2], round(255 * m / 2)))
    qp.drawPoint(cur_x, cur_y)
    last_p_x = -1
    # if start_y == end_y:
    #     breakpoint()
    last_p_y = - 1
    for i in range(dx + 1):
        if e < w:
            if trade:
                cur_y += sy
            else:
                cur_x += sx
            e += m
        else:
            cur_x += sx
            cur_y += sy
            e -= w
        if abs(w - 1) < 1e-6:
            qp.setPen(QtGui.QColor(colors[0], colors[1], colors[2], 255))
        else:
            qp.setPen(QtGui.QColor(colors[0], colors[1], colors[2], round(255 * e)))
        qp.drawPoint(cur_x, cur_y)
        if last_p_x != cur_x and last_p_y != cur_y:
            ladders += 1
            last_p_x = cur_x
            last_p_y = cur_y
    qp.setPen(QtGui.QColor(save_color))


def clearScene(x: int, y: int, w: int, h: int, qp: QPainter):
    qp.eraseRect(x, y, w, h)


class Ui_MainWindow(object):
    def __init__(self, MainWindow):
        self.main_window = MainWindow
        self.setupUi(MainWindow)
        # self.scene_objects: mediator.SceneObjects = scene_objects

    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1074, 740)

        font = QtGui.QFont()
        font.setPointSize(13)
        MainWindow.setFont(font)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.ex = Example(parent=self.centralwidget)
        self.alg_choose_1 = QtWidgets.QComboBox(parent=self.centralwidget)
        self.alg_choose_1.setGeometry(QtCore.QRect(10, 10, 421, 81))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.alg_choose_1.sizePolicy().hasHeightForWidth())
        self.alg_choose_1.setSizePolicy(sizePolicy)
        self.alg_choose_1.setMaximumSize(QtCore.QSize(421, 16777215))
        font = QtGui.QFont()
        font.setPointSize(14)
        self.alg_choose_1.setFont(font)
        self.alg_choose_1.setContextMenuPolicy(QtCore.Qt.ContextMenuPolicy.DefaultContextMenu)
        self.alg_choose_1.setModelColumn(0)
        self.alg_choose_1.setObjectName("alg_choose_1")
        self.alg_choose_1.addItem("")
        self.alg_choose_1.addItem("")
        self.alg_choose_1.addItem("")
        self.alg_choose_1.addItem("")
        self.alg_choose_1.addItem("")
        self.alg_choose_1.addItem("")
        self.color_choose_1 = QtWidgets.QComboBox(parent=self.centralwidget)
        self.color_choose_1.setGeometry(QtCore.QRect(10, 100, 421, 41))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.color_choose_1.sizePolicy().hasHeightForWidth())
        self.color_choose_1.setSizePolicy(sizePolicy)
        self.color_choose_1.setMaximumSize(QtCore.QSize(421, 16777215))
        font = QtGui.QFont()
        font.setPointSize(14)
        self.color_choose_1.setFont(font)
        self.color_choose_1.setContextMenuPolicy(QtCore.Qt.ContextMenuPolicy.DefaultContextMenu)
        self.color_choose_1.setModelColumn(0)
        self.color_choose_1.setObjectName("color_choose_1")
        self.color_choose_1.addItem("")
        self.color_choose_1.addItem("")
        self.color_choose_1.addItem("")
        # self.size_choose_1 = QtWidgets.QComboBox(parent=self.centralwidget)
        # self.size_choose_1.setGeometry(QtCore.QRect(10, 150, 421, 41))
        # sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Fixed)
        # sizePolicy.setHorizontalStretch(0)
        # sizePolicy.setVerticalStretch(0)
        # sizePolicy.setHeightForWidth(self.size_choose_1.sizePolicy().hasHeightForWidth())
        # self.size_choose_1.setSizePolicy(sizePolicy)
        # self.size_choose_1.setMaximumSize(QtCore.QSize(421, 16777215))
        # font = QtGui.QFont()
        # font.setPointSize(14)
        # self.size_choose_1.setFont(font)
        # self.size_choose_1.setContextMenuPolicy(QtCore.Qt.ContextMenuPolicy.DefaultContextMenu)
        # self.size_choose_1.setModelColumn(0)
        # self.size_choose_1.setObjectName("size_choose_1")
        # self.size_choose_1.addItem("")
        self.clear_scene_button = QtWidgets.QPushButton(parent=self.centralwidget)
        self.clear_scene_button.setGeometry(QtCore.QRect(60, 640, 320, 28))
        self.clear_scene_button.setObjectName("clear_scene_button")
        self.draw_button = QtWidgets.QPushButton(parent=self.centralwidget)
        self.draw_button.setGeometry(QtCore.QRect(30, 270, 390, 28))
        self.draw_button.setObjectName("draw_button")
        self.center_label_2 = QtWidgets.QLabel(parent=self.centralwidget)
        self.center_label_2.setGeometry(QtCore.QRect(50, 320, 320, 20))
        self.center_label_2.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.center_label_2.setObjectName("center_label_2")
        self.draw_spectrum_button = QtWidgets.QPushButton(parent=self.centralwidget)
        self.draw_spectrum_button.setGeometry(QtCore.QRect(60, 520, 320, 28))
        self.draw_spectrum_button.setObjectName("draw_spectrum_button")
        self.angle_value = QtWidgets.QLineEdit(parent=self.centralwidget)
        self.angle_value.setGeometry(QtCore.QRect(160, 350, 191, 28))
        self.angle_value.setObjectName("angle_value")
        self.length_label = QtWidgets.QLabel(parent=self.centralwidget)
        self.length_label.setGeometry(QtCore.QRect(9, 390, 141, 28))
        self.length_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.length_label.setObjectName("length_label")
        self.angle_label = QtWidgets.QLabel(parent=self.centralwidget)
        self.angle_label.setGeometry(QtCore.QRect(9, 350, 141, 28))
        self.angle_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.angle_label.setObjectName("angle_label")
        self.length_value = QtWidgets.QLineEdit(parent=self.centralwidget)
        self.length_value.setGeometry(QtCore.QRect(160, 390, 191, 28))
        self.length_value.setObjectName("length_value")
        self.graph_ladders_button = QtWidgets.QPushButton(parent=self.centralwidget)
        self.graph_ladders_button.setGeometry(QtCore.QRect(30, 560, 401, 28))
        self.graph_ladders_button.setObjectName("graph_ladders_button")
        # self.graph_time_angle_button = QtWidgets.QPushButton(parent=self.centralwidget)
        # self.graph_time_angle_button.setGeometry(QtCore.QRect(30, 600, 400, 28))
        # self.graph_time_angle_button.setObjectName("graph_time_angle_button")
        self.graph_avg_time_button = QtWidgets.QPushButton(parent=self.centralwidget)
        self.graph_avg_time_button.setGeometry(QtCore.QRect(20, 600, 420, 28))
        self.graph_avg_time_button.setObjectName("graph_avg_time_button")
        self.p1_x_value = QtWidgets.QLineEdit(parent=self.centralwidget)
        self.p1_x_value.setGeometry(QtCore.QRect(120, 190, 113, 28))
        self.p1_x_value.setObjectName("p1_x_value")
        self.p1_y_label = QtWidgets.QLabel(parent=self.centralwidget)
        self.p1_y_label.setGeometry(QtCore.QRect(30, 230, 80, 28))
        self.p1_y_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.p1_y_label.setObjectName("p1_y_label")
        self.p1_x_label = QtWidgets.QLabel(parent=self.centralwidget)
        self.p1_x_label.setGeometry(QtCore.QRect(30, 190, 80, 28))
        self.p1_x_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.p1_x_label.setObjectName("p1_x_label")
        self.p1_y_value = QtWidgets.QLineEdit(parent=self.centralwidget)
        self.p1_y_value.setGeometry(QtCore.QRect(120, 230, 113, 28))
        self.p1_y_value.setObjectName("p1_y_balue")
        self.p2_x_value = QtWidgets.QLineEdit(parent=self.centralwidget)
        self.p2_x_value.setGeometry(QtCore.QRect(350, 190, 113, 28))
        self.p2_x_value.setObjectName("p2_x_value")
        self.p2_y_label = QtWidgets.QLabel(parent=self.centralwidget)
        self.p2_y_label.setGeometry(QtCore.QRect(260, 230, 80, 28))
        self.p2_y_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.p2_y_label.setObjectName("p2_y_label")
        self.p2_x_label = QtWidgets.QLabel(parent=self.centralwidget)
        self.p2_x_label.setGeometry(QtCore.QRect(260, 190, 80, 28))
        self.p2_x_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.p2_x_label.setObjectName("p2_x_label")
        self.p2_y_value = QtWidgets.QLineEdit(parent=self.centralwidget)
        self.p2_y_value.setGeometry(QtCore.QRect(350, 230, 113, 28))
        self.p2_y_value.setObjectName("p2_y_value")
        self.p1_label = QtWidgets.QLabel(parent=self.centralwidget)
        self.p1_label.setGeometry(QtCore.QRect(0, 150, 250, 28))
        self.p1_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.p1_label.setObjectName("p1_label")
        self.p2_label = QtWidgets.QLabel(parent=self.centralwidget)
        self.p2_label.setGeometry(QtCore.QRect(250, 150, 240, 28))
        self.p2_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.p2_label.setObjectName("p2_label")
        # self.alg_choose_2 = QtWidgets.QComboBox(parent=self.centralwidget)
        # self.alg_choose_2.setGeometry(QtCore.QRect(10, 430, 421, 81))
        # sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Fixed)
        # sizePolicy.setHorizontalStretch(0)
        # sizePolicy.setVerticalStretch(0)
        # sizePolicy.setHeightForWidth(self.alg_choose_2.sizePolicy().hasHeightForWidth())
        # self.alg_choose_2.setSizePolicy(sizePolicy)
        # self.alg_choose_2.setMaximumSize(QtCore.QSize(421, 16777215))
        # font = QtGui.QFont()
        # font.setPointSize(14)
        # self.alg_choose_2.setFont(font)
        # self.alg_choose_2.setContextMenuPolicy(QtCore.Qt.ContextMenuPolicy.DefaultContextMenu)
        # self.alg_choose_2.setModelColumn(0)
        # self.alg_choose_2.setObjectName("alg_choose_1")
        # self.alg_choose_2.addItem("")
        # self.alg_choose_2.addItem("")
        # self.alg_choose_2.addItem("")
        # self.alg_choose_2.addItem("")
        # self.alg_choose_2.addItem("")
        # self.alg_choose_2.addItem("")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1074, 26))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.alg_choose_1.setCurrentIndex(0)
        self.color_choose_1.setCurrentIndex(0)
        # self.size_choose_1.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        self.make_connects()

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.alg_choose_1.setItemText(0, _translate("MainWindow", "Алгоритм Брезенхема с\nдействительными данными"))
        self.alg_choose_1.setItemText(1, _translate("MainWindow", "Алгоритм Брезенхема с\nцелочисленными данными"))
        self.alg_choose_1.setItemText(2, _translate("MainWindow", "Алгоритм Брезенхема с\nустранением ступенчатости"))
        self.alg_choose_1.setItemText(3, _translate("MainWindow", "Алгоритм ВУ"))
        self.alg_choose_1.setItemText(4, _translate("MainWindow", "Алгоритм ЦДА"))
        self.alg_choose_1.setItemText(5, _translate("MainWindow", "Библиотечный алгоритм"))

        # self.alg_choose_2.setItemText(0, _translate("MainWindow", "Алгоритм Брезенхема с\nдействительными данными"))
        # self.alg_choose_2.setItemText(1, _translate("MainWindow", "Алгоритм Брезенхема с\nцелочисленными данными"))
        # self.alg_choose_2.setItemText(2, _translate("MainWindow", "Алгоритм Брезенхема с\nустранением ступенчатости"))
        # self.alg_choose_2.setItemText(3, _translate("MainWindow", "Алгоритм ВУ"))
        # self.alg_choose_2.setItemText(4, _translate("MainWindow", "Алгоритм ЦДА"))
        # self.alg_choose_2.setItemText(5, _translate("MainWindow", "Библиотечный алгоритм"))

        self.color_choose_1.setItemText(0, _translate("MainWindow", "Черный"))
        self.color_choose_1.setItemText(1, _translate("MainWindow", "Белый"))
        self.color_choose_1.setItemText(2, _translate("MainWindow", "Красный"))
        # self.size_choose_1.setItemText(0, _translate("MainWindow", "Пиксели нормального размера"))
        self.clear_scene_button.setText(_translate("MainWindow", "Очистить холст"))
        self.draw_button.setText(_translate("MainWindow", "Нарисовать"))
        self.center_label_2.setText(_translate("MainWindow", "Построение спектра"))
        self.draw_spectrum_button.setText(_translate("MainWindow", "Построить спектр"))
        self.length_label.setText(_translate("MainWindow", "Длина отрезка:"))
        self.angle_label.setText(_translate("MainWindow", "Угол поворота:"))
        self.graph_ladders_button.setText(_translate("MainWindow", "Построить графики ступенек от угла наклона"))
        # self.graph_time_angle_button.setText(_translate("MainWindow", "Построить графики времени от угла наклона"))
        self.graph_avg_time_button.setText(_translate("MainWindow", "Построить графики среднего времени по спектру"))
        self.p1_x_label.setText(_translate("MainWindow", "x1:"))
        self.p1_y_label.setText(_translate("MainWindow", "y1:"))
        self.p2_x_label.setText(_translate("MainWindow", "x2:"))
        self.p2_y_label.setText(_translate("MainWindow", "y2:"))
        self.p1_label.setText(_translate("MainWindow", "Координаты первой точки:"))
        self.p2_label.setText(_translate("MainWindow", "Координаты второй точки:"))

    def make_connects(self):
        self.clear_scene_button.clicked.connect(self.clear_scene_button_handler)
        self.draw_button.clicked.connect(self.draw_button_handler)
        self.draw_spectrum_button.clicked.connect(self.draw_spectrum_button_handler)
        self.graph_ladders_button.clicked.connect(self.graph_ladders_button_handler)
        self.graph_avg_time_button.clicked.connect(self.graph_avg_time_button_handler)
        # self.graph_time_angle_button.clicked.connect(self.graph_time_angle_button_handler)

    def clear_scene_button_handler(self):
        self.ex.clear_lines_list()
        self.ex.add_line((490, 20, 570, 700, QtGui.QColor("black"), clearScene))
        self.ex.update()

    @staticmethod
    def validate(req_type: Type[float], s: str) -> bool:
        """
        Проверяет, что функция соответствует переданному типу.

        :param req_type: Ожидаемый тип, к которому должна быть приводима строка.
        :param s: Строка.
        :return: Является ли строка корректным значением.
        """
        try:
            req_type(s)
        except ValueError:
            return False
        else:
            return True

    def draw_button_handler(self):
        if not self.alg_choose_1.currentText():
            self.show_error("Ошибка отрисовки", "Не выбран алгоритм отрисовки")
            return
        if not self.color_choose_1.currentText():
            self.show_error("Ошибка отрисовки", "Не выбран цвет отрисовки")
            return
        if not self.validate(int, self.p1_x_value.text()):
            self.show_error("Ошибка отрисовки", "Не задана координата x начала отрезка")
            return
        if not self.validate(int, self.p1_y_value.text()):
            self.show_error("Ошибка отрисовки", "Не задана координата y начала отрезка")
            return
        if not self.validate(int, self.p2_x_value.text()):
            self.show_error("Ошибка отрисовки", "Не задана координата x конца отрезка")
            return
        if not self.validate(int, self.p2_y_value.text()):
            self.show_error("Ошибка отрисовки", "Не задана координата y конца отрезка")
            return
        text_to_func: dict[str, Callable[[int, int, int, int, QPainter], None]] = {
            "алгоритм брезенхема с\nдействительными данными": bresenham_algorithm_float,
            "алгоритм брезенхема с\nцелочисленными данными": bresenham_algorithm_int,
            "алгоритм брезенхема с\nустранением ступенчатости": light_brem,
            "алгоритм ву": alg_vu,
            "алгоритм цда": digital_differential_analyzer,
            "библиотечный алгоритм": None
        }
        drawing_func = text_to_func[self.alg_choose_1.currentText().lower()]
        translate_text: dict[str, str] = {"черный": "black", "красный": "red", "белый": "white"}
        color: QtGui.QColor = QtGui.QColor(translate_text[self.color_choose_1.currentText().lower()])
        x1: int = int(self.p1_x_value.text())
        y1: int = int(self.p1_y_value.text())
        x2: int = int(self.p2_x_value.text())
        y2: int = int(self.p2_y_value.text())
        len_info: tuple[int, int, int, int, QtGui.QColor, Callable] = (x1, y1, x2, y2, color, drawing_func)
        # self.ex.set_draw_method(drawing_func)
        self.ex.clear_lines_list()
        self.ex.add_line(len_info)
        self.ex.update()
        # self.scene.addRect(100, 100, 0.05, 0.05, QtGui.QPen(QtGui.QColor("green"), 1))

    def draw_spectrum_button_handler(self):
        if not self.alg_choose_1.currentText():
            self.show_error("Ошибка отрисовки спектра", "Не выбран алгоритм основным цветом")
            return
        # if not self.alg_choose_2.currentText():
        #     self.show_error("Ошибка отрисовки спектра", "Не выбран алгоритм цветом фона")
        #     return
        if not self.validate(float, self.angle_value.text()):
            self.show_error("Ошибка отрисовки спектра", "Задан некорректный угол")
            return
        if not self.validate(float, self.length_value.text()):
            self.show_error("Ошибка отрисовки спектра", "Задана некорректная длина")
            return
        if not self.color_choose_1.currentText():
            self.show_error("Ошибка отрисовки", "Не выбран цвет отрисовки")
            return
        text_to_func: dict[str, typing.Callable[[int, int, int, int, QPainter], None]] = {
            "алгоритм брезенхема с\nдействительными данными": bresenham_algorithm_float,
            "алгоритм брезенхема с\nцелочисленными данными": bresenham_algorithm_int,
            "алгоритм брезенхема с\nустранением ступенчатости": light_brem,
            "алгоритм ву": alg_vu,
            "алгоритм цда": digital_differential_analyzer,
            "библиотечный алгоритм": None
        }
        drawing_func = text_to_func[self.alg_choose_1.currentText().lower()]
        translate_text: dict[str, str] = {"черный": "black", "красный": "red", "белый": "white"}
        color: QtGui.QColor = QtGui.QColor(translate_text[self.color_choose_1.currentText().lower()])
        # drawing_func2 = text_to_func[self.alg_choose_2.currentText().lower()]
        angle = float(self.angle_value.text())
        l = float(self.length_value.text())
        center = (285, 325)
        # angle = 2
        """
        cp_x = self.x
        cp_y = self.y
        self.x = (cp_x - center.x) * cos(angle) + (cp_y - center.y) * sin(angle) + center.x
        self.y = (cp_x - center.x) * -sin(angle) + (cp_y - center.y) * cos(angle) + center.y
        """
        math_angle = 0
        cur_angle = angle / 180 * math.pi
        start_x = center[0]
        start_y = center[1] - l // 2
        end_x = center[0]
        end_y = center[1] + (l + 1) // 2
        # self.ex.set_draw_method(drawing_func)
        # self.ex.clear_lines_list()
        for i in range(180 // int(angle)):
            build_x1 = (start_x - center[0]) * math.cos(math_angle) + (start_y - center[1]) * math.sin(math_angle) + \
                       center[0]
            build_y1 = -(start_x - center[0]) * math.sin(math_angle) + (start_y - center[1]) * math.cos(math_angle) + \
                       center[1]
            build_x2 = (end_x - center[0]) * math.cos(math_angle) + (end_y - center[1]) * math.sin(math_angle) + \
                       center[0]
            build_y2 = -(end_x - center[0]) * math.sin(math_angle) + (end_y - center[1]) * math.cos(math_angle) + \
                       center[1]
            self.ex.add_line(
                (int(build_x1), int(build_y1), int(build_x2), int(build_y2), color, drawing_func))
            # self.ex.add_line(
            #     (int(build_x1), int(build_y1), int(build_x2), int(build_y2), QtGui.QColor("white"), drawing_func2))
            math_angle += cur_angle
        self.ex.update()

    def graph_ladders_button_handler(self):
        res = self.calc_ladders()
        # print(res)
        for el in res:
            show_graph(tuple(x for x in range(0, 90)), res[el], el)
        # plt.show()
        # show_graph(, res.values())

    def graph_avg_time_button_handler(self):
        res = self.calc_build_time()
        print(res)
        show_bar(res.keys(), res.values())

    def show_error(self, title: str, message: str) -> None:
        """
        Отображение сообщения об ошибке.

        :param title: Заголовок сообщения
        :param message: Текст сообщения
        :return: None
        """
        QMessageBox.critical(self.main_window, title, message)

    def redraw_scene(self):
        pass
        # print(self.color_choose_1.currentText())
        # self.scene.clear()
        # digital_differential_analyzer(logic.Point(0, 0), logic.Point(100, 100), QtGui.QColor("black"), self.scene)

    def calc_ladders(self):
        angle = 1
        l = 200
        center = (285, 325)
        start_x = center[0]
        start_y = center[1] - l // 2
        end_x = center[0]
        end_y = center[1] + (l + 1) // 2

        algs = (
            bresenham_algorithm_float,
            # int_bres,
            bresenham_algorithm_int,
            light_brem,
            alg_vu,
            digital_differential_analyzer,
        )
        alg_names = ("bres_float", "bres_int", "light_brem", "alg_vu", "digital")
        times = dict.fromkeys(alg_names, 0)
        draw_lines = []
        math_angle = 0
        cur_angle = angle / 180 * math.pi

        for i in range(90 // int(angle)):
            build_x1 = (start_x - center[0]) * math.cos(math_angle) + (start_y - center[1]) * math.sin(math_angle) + \
                       center[0]
            build_y1 = -(start_x - center[0]) * math.sin(math_angle) + (start_y - center[1]) * math.cos(
                math_angle) + \
                       center[1]
            build_x2 = (end_x - center[0]) * math.cos(math_angle) + (end_y - center[1]) * math.sin(math_angle) + \
                       center[0]
            build_y2 = -(end_x - center[0]) * math.sin(math_angle) + (end_y - center[1]) * math.cos(math_angle) + \
                       center[1]
            draw_lines.append(
                (int(build_x1), int(build_y1), int(build_x2), int(build_y2), QPainter()))
            math_angle += cur_angle
        for num, alg in enumerate(algs):
            data = []
            for line in draw_lines:
                alg(*line, calc_ladders=True)
                data.append(ladders)
            times[alg_names[num]] = data
            # times[alg_names[num]] = timeit.timeit('self.ex.update()', number=10000)
        return times

    def calc_build_time(self):

        # if not self.validate(float, self.angle_value.text()):
        #     self.show_error("Ошибка отрисовки спектра", "Задан некорректный угол")
        #     return
        # if not self.validate(float, self.length_value.text()):
        #     self.show_error("Ошибка отрисовки спектра", "Задана некорректная длина")
        #     return
        # angle = float(self.angle_value.text())
        # l = float(self.length_value.text())
        angle = 30
        l = 500
        center = (285, 325)
        start_x = center[0]
        start_y = center[1] - l // 2
        end_x = center[0]
        end_y = center[1] + (l + 1) // 2

        algs = (
            bresenham_algorithm_float,
            # int_bres,
            bresenham_algorithm_int,
            light_brem,
            alg_vu,
            digital_differential_analyzer,
        )
        alg_names = ("bres_float", "bres_int", "light_brem", "alg_vu", "digital")
        starts_arr = (12, 9, 10, 15, 11)
        times = dict.fromkeys(alg_names, 0)
        draw_lines = []
        math_angle = 0
        cur_angle = angle / 180 * math.pi

        for i in range(180 // int(angle)):
            build_x1 = (start_x - center[0]) * math.cos(math_angle) + (start_y - center[1]) * math.sin(math_angle) + \
                       center[0]
            build_y1 = -(start_x - center[0]) * math.sin(math_angle) + (start_y - center[1]) * math.cos(
                math_angle) + \
                       center[1]
            build_x2 = (end_x - center[0]) * math.cos(math_angle) + (end_y - center[1]) * math.sin(math_angle) + \
                       center[0]
            build_y2 = -(end_x - center[0]) * math.sin(math_angle) + (end_y - center[1]) * math.cos(math_angle) + \
                       center[1]
            draw_lines.append(
                (int(build_x1), int(build_y1), int(build_x2), int(build_y2), QPainter()))
            math_angle += cur_angle
        for num, alg in enumerate(algs):
            starts = starts_arr[num]
            # start = time.time()
            # for i in range(starts):
            #     self.ex.update()
            # end = time.time()
            start = time.perf_counter()
            for i in range(starts):
                for line in draw_lines:
                    alg(*line)
            end = time.perf_counter()
            times[alg_names[num]] = (end - start) / 10
            # times[alg_names[num]] = timeit.timeit('self.ex.update()', number=10000)
        return times


if __name__ == "__main__":
    show_bar(0, 0)
